#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
BASE_DIR="$( cd $SCRIPT_DIR && cd .. & pwd)"

CYAN="\033[96m"
YELLOW="\033[93m"
GREEN="\033[32m"
PURPLE="\033[35m"
RED="\033[31m"
RESET="\033[0m"
BOLD="\033[1m"

ORG=rancher
BRANCH=main

echo -e "${CYAN}${BOLD}Patch mechanism for extensions${RESET}"

EXTS_ARRAY=()
while IFS= read -r EXT; do
    EXTS_ARRAY+=("$EXT")
done < <(jq -r ".extensions | keys[]" manifest.json)

TMP=${BASE_DIR}/tmp
rm -rf ${TMP}
mkdir -p ${TMP}

REPOSITORY=${ORG}/ui-plugin-charts


# --- Function to convert SemVer to sortable format ---
semver_to_sortable() {
  local version=$(echo "$1" | tr '+' '-' | cut -d '-' -f 1)
  
  [[ -z "$version" ]] && return 1

  local PADDED_VERSION
  
  # Read components into an array
  IFS='.' read -r -a V_PARTS <<< "$version"
  
  for part in "${V_PARTS[@]}"; do
    PADDED_VERSION+="$(printf '%03d' "$part")."
  done
  
  echo "${PADDED_VERSION%.}"
}

# --- Function to compare two versions (V1 operator V2) ---
semver_check() {
  local V1="$1"
  local OP="$2"
  local V2="$3" 
  
  local SV1=$(semver_to_sortable "$V1")
  local SV2=$(semver_to_sortable "$V2")

  if [[ "$OP" == "=" ]]; then
    [[ "$SV1" == "$SV2" ]]
  elif [[ "$OP" == ">" ]]; then
    [[ "$SV1" > "$SV2" ]]
  elif [[ "$OP" == "<" ]]; then
    [[ "$SV1" < "$SV2" ]]
  elif [[ "$OP" == ">=" ]]; then
    [[ "$SV1" == "$SV2" || "$SV1" > "$SV2" ]]
  elif [[ "$OP" == "<=" ]]; then
    [[ "$SV1" == "$SV2" || "$SV1" < "$SV2" ]]
  else
    echo "Error: Invalid operator $OP" >&2
    return 1
  fi
}


echo "GitHub Repository: ${REPOSITORY}"
echo "GitHub Branch:     ${BRANCH}"

# syncing new charts into this repo
for NAME in "${EXTS_ARRAY[@]}" 
do
  echo -e "${CYAN} + Syncing: ${BOLD}${NAME}${RESET}"

  # Make diretories for assets, charts, and extensions
  mkdir -p ./assets/${NAME}
  mkdir -p ./charts/${NAME}
  mkdir -p ./extensions/${NAME}

  # Get repository name, branch, and versions
  REPO=$(jq -r ".extensions.\"${NAME}\".repo" manifest.json)
  EXT_BRANCH=$(jq -r ".extensions.\"${NAME}\".branch" manifest.json)
  
  VERSIONS_ARRAY=()
  while IFS= read -r V; do
    VERSIONS_ARRAY+=("$V")
  done < <(jq -r ".extensions.\"${NAME}\".versions[]" manifest.json)

  # Display versions for user
  VFORMAT=$(IFS=$' '; echo "${VERSIONS_ARRAY[*]}")

  echo -e "     Repository: ${REPO}"
  echo -e "     Branch: ${EXT_BRANCH}"
  echo -e "     Versions  : ${VFORMAT}"
  echo ""

  for VERSION in "${VERSIONS_ARRAY[@]}" 
  do
    echo -e "${CYAN}     Syncing: ${BOLD}${NAME}@${VERSION}${RESET}"

    if [ -d "./patches/${NAME}" ]; then
      echo -e "${YELLOW}      Patching structure found in repo for chart ${NAME}${RESET}"
      echo -e "${YELLOW}      Checking if we need to re-patch it ${RESET}"

      BASE_PATCH_DIR="./patches/${NAME}"

      JSON_PATCH="${BASE_PATCH_DIR}/patches.json"
      echo -e "${BOLD}(1) :::::: Checking if ${JSON_PATCH} exists ${RESET}"
      
      if [ -f "$JSON_PATCH" ]; then
        echo -e "${GREEN}The file $JSON_PATCH exists and is a regular file${RESET}"

        BASE_ICON_NAME="icon"

        # variables to control tgz part so that we do all operations at onces
        APPLY_DESCRIPTION="false"
        APPLY_ICON="false"
        APPLY_README="false"
        APPLY_NAME="false"
        APPLY_ANNOTATIONS="false"

        # These are related to the JQ query below... If we change the defaults on the query
        # we should change these variables as well
        NO_VERSION="N/A"
        NO_NAME="No Name"
        NO_DESCRIPTION="No Description"
        NO_ANNOTATIONS="N/A"

        JQ_QUERY='
        .patches[] | 
          [
            .dir // "N/A",
            .versions // "N/A",
            .name // "No Name", 
            .description // "No Description",
            (
              if .annotations then
                [ (.annotations | to_entries[] | "\(.key)=\(.value)") ] | join("|")
              else
                "N/A"
              end
            )
          ] | @csv
        '

        # Store the original IFS *before* the while loop starts
        OLD_IFS="$IFS"

        # Use process substitution to read all JQ output
        while IFS=',' read -r DIR_QUOTED VERSION_RANGE_QUOTED PATCH_NAME_QUOTED PATCH_DESCRIPTION_QUOTED ANNO_STRING_QUOTED; do
          echo "--- Starting Patch Traversal ---"

          # 1. Strip quotes and clean variables
          ANNO_BLOCK="${ANNO_STRING_QUOTED#?}"
          ANNO_BLOCK="${ANNO_BLOCK%?}"
          
          ANNO_STRING=$(echo "$ANNO_BLOCK" | tr -d '\r')

          DIR="${DIR_QUOTED//\"/}"
          VERSION_RANGE="${VERSION_RANGE_QUOTED//\"/}"
          PATCH_NAME="${PATCH_NAME_QUOTED//\"/}"
          PATCH_DESCRIPTION="${PATCH_DESCRIPTION_QUOTED//\"/}"

          echo "---------------------------------------------------------"
          echo "Processing Patch for Directory: **$DIR**"
          echo "Required Versions: $VERSION_RANGE"
          echo "Name: $PATCH_NAME"
          echo "Description: $PATCH_DESCRIPTION"
          
          # check VERSION in patches.json (evaluate condition)
          # Status tracker for compound conditions (logical AND)
          REQUIRED_STATUS=0 # 0 means TRUE (patch is required)
          
          if [[ "$VERSION_RANGE" == "$NO_VERSION" ]]; then
            echo -e "${PURPLE}⚠️ Patch skipped, invalid version range 'N/A'${RESET}"
            continue
          fi

          # Split the VERSION_RANGE string by space into an array of conditions
          IFS=' ' read -r -a CONDITIONS <<< "$VERSION_RANGE"
          
          for CONDITION in "${CONDITIONS[@]}"; do
            # 1. Determine operator ($OP) and version ($V2) from the single CONDITION
            if [[ "$CONDITION" == ">="* ]]; then
              OP=">="
              V2="${CONDITION:2}"
            elif [[ "$CONDITION" == "<="* ]]; then
              OP="<="
              V2="${CONDITION:2}"
            elif [[ "$CONDITION" == ">"* ]]; then
              OP=">"
              V2="${CONDITION:1}"
            elif [[ "$CONDITION" == "<"* ]]; then
              OP="<"
              V2="${CONDITION:1}"
            elif [[ "$CONDITION" == "="* ]]; then
              OP="="
              V2="${CONDITION:1}"
            elif [[ "$CONDITION" =~ ^[0-9] ]]; then
              OP="="
              V2="$CONDITION"
            else
              echo "⚠️ Sub-condition failed due to unparseable version range: $CONDITION" >&2
              REQUIRED_STATUS=1 # Treat unparseable as failure
              break
            fi
            
            # 2. Call the function for this single condition
            if ! semver_check "$VERSION" "$OP" "$V2"; then
              REQUIRED_STATUS=1 # Condition failed (Logical AND)
              break
            fi
          done

          # VERSION in patches.json final status
          if [[ $REQUIRED_STATUS -eq 0 ]]; then
            echo -e "${BOLD}✅✅✅✅ Patch can be applied for target version $VERSION${RESET}"
          else
            echo -e "${RED}❌ Patch is SKIPPED for target version $VERSION${RESET}"
            echo -e "${RED}----------------------------------${RESET}"
            echo -e "${RED}----------------------------------${RESET}"
            continue
          fi

          # check apply new PATCH NAME
          if [[ -n "$PATCH_NAME" && "$PATCH_NAME" != "$NO_NAME" ]]; then
            CURR_PACKAGE_JSON="${BASE_DIR}/extensions/${NAME}/${VERSION}/plugin/package.json"

            if [[ ! -f "$CURR_PACKAGE_JSON" ]]; then
              echo -e "${RED}${BOLD}PATCH NAME ::: There's no PACKAGE.JSON on the extension!!!! something is seriously wrong!!! let's terminate this operation!${RESET}"
              exit 1
            else
              echo -e "${YELLOW}${BOLD}PATCH NAME ::: There's a new name to be applied, let's apply it then...${RESET}"
              APPLY_NAME="true"
            fi
          else
            echo -e "${PURPLE}PATCH NAME ::: The Patch 'Name' is empty OR is ${NO_NAME}. Let's skip the 'name' change...${RESET}"
          fi

          # check apply new PATCH_DESCRIPTION
          if [[ -n "$PATCH_DESCRIPTION" && "$PATCH_DESCRIPTION" != "$NO_DESCRIPTION" ]]; then
            CURR_PACKAGE_JSON="${BASE_DIR}/extensions/${NAME}/${VERSION}/plugin/package.json"

            if [[ ! -f "$CURR_PACKAGE_JSON" ]]; then
              echo -e "${RED}${BOLD}PATCH_DESCRIPTION ::: There's no PACKAGE.JSON on the extension!!!! something is seriously wrong!!! let's terminate this operation!${RESET}"
              exit 1
            else
              APPLY_DESCRIPTION="true"
              echo -e "${YELLOW}${BOLD}PATCH_DESCRIPTION ::: There's a new DESCRIPTION. We need to apply it...${RESET}"
            fi
          else
            echo -e "${PURPLE}PATCH DESCRIPTION ::: The Patch 'description' is empty OR is ${NO_DESCRIPTION}. Let's skip the 'description' change...${RESET}"
          fi

          echo "Annotations:"
          echo "--- Annotation Details ---"

          # 4. Split the annotation string by the pipe delimiter (|)
          if [[ "$ANNO_STRING" == "$NO_ANNOTATIONS" ]]; then
            echo -e "${PURPLE}ANNOTATIONS :::  No annotations found... Let's skip the annotations change...${RESET}"
          else
            echo -e "${YELLOW}${BOLD}ANNOTATIONS ::: We have new annotations, let's apply them...${RESET}"
            APPLY_ANNOTATIONS="true"
          fi

          # check apply new README and ICON
          if [ -d "${BASE_PATCH_DIR}/${DIR}" ]; then
            NEW_README="${BASE_PATCH_DIR}/${DIR}/README.md"
            CURR_README="${BASE_DIR}/charts/${NAME}/${VERSION}/README.md"

            # Check if both README files exist before attempting the comparison
            if [[ ! -f "$NEW_README" ]]; then
              echo -e "${PURPLE}README ::: There is no README to apply as patch... let's skip it...${RESET}"
            else
              if [[ ! -f "$CURR_README" ]]; then
                echo -e "${YELLOW}${BOLD}README ::: There's no README on this extension version. We need to apply one...${RESET}"
                APPLY_README="true"
              else
                # The 'cmp -s' command compares the files.
                # It returns an exit status of 0 if the contents are identical.
                if cmp -s "$NEW_README" "$CURR_README"; then
                  echo -e "${PURPLE}README ::: The content of $NEW_README and $CURR_README are identical. we can skip it....${RESET}"
                else
                  echo -e "${YELLOW}${BOLD}README ::: README files are different... Let's apply it then${RESET}"
                  APPLY_README="true"           
                fi
              fi
            fi

            # check ICON
            ICON_FILE=("${BASE_PATCH_DIR}/${DIR}/${BASE_ICON_NAME}."*)

            if [[ ! -f "${ICON_FILE[0]}" ]]; then
              echo -e "${PURPLE}ICON ::: There is no ICON to apply as patch... let's skip it...${RESET}"
            else
              echo -e "${YELLOW}${BOLD}ICON ::: There's a new ICON. We need to apply it...${RESET}"
              APPLY_ICON="true"
            fi
          else
            echo "${PURPLE}There's no folder for the README or ICON file... let's skip these steps..."
          fi

          # here we manage the changes to all of the prior checks
          if [[ "$APPLY_DESCRIPTION" == "true" || "$APPLY_ICON" == "true" || "$APPLY_README" == "true"  || "$APPLY_NAME" == "true" || "$APPLY_ANNOTATIONS" == "true" ]]; then

            # handle DESCRIPTION
            if [[ "$APPLY_ICON" == "true" ]]; then
              jq --arg key "description" --arg value "$PATCH_DESCRIPTION" '.[$key] = $value' "$CURR_PACKAGE_JSON" > "$CURR_PACKAGE_JSON.tmp" && mv "$CURR_PACKAGE_JSON.tmp" "$CURR_PACKAGE_JSON"
              
              echo -e "${BOLD}${GREEN}PATCH DESCRIPTION ::: =>=>=> New 'description' ${PATCH_DESCRIPTION} should have been successfully applied${RESET}"
            fi

            # handle ICON
            if [[ "$APPLY_ICON" == "true" ]]; then
              # copy ICON to icons folder
              SOURCE_FOLDER="${BASE_PATCH_DIR}/${DIR}" 
              DEST_FOLDER="./icons/${NAME}"             
              NEW_ICON_NAME="patched-icon-${NAME}-${VERSION}"               

              # Use the glob pattern to reliably capture the full filename
              MAPFILE=("${SOURCE_FOLDER}/${BASE_ICON_NAME}."*)
              SOURCE_PATH="${MAPFILE[0]}"

              # Extract the exact file extension using Bash Parameter Expansion
              # This removes the longest prefix ending in a dot (e.g., from './icon.svg', it keeps 'svg')
              EXTENSION="${SOURCE_PATH##*.}"
              echo "Extracted extension of ICON: .${EXTENSION}"

              # Construct the full destination path
              # Example: /tmp/elemental/icon.svg
              DEST_PATH="${DEST_FOLDER}/${NEW_ICON_NAME}.${EXTENSION}"
              
              # Perform the copy and rename operation
              if cp -fr "$SOURCE_PATH" "$DEST_PATH"; then
                echo -e "${GREEN}ICON ::: Icon file copied and renamed to $NEW_ICON_NAME.${EXTENSION} in temp folder.${RESET}"
              else
                echo -e "${RED}ICON ::: Failed to copy icon file from $SOURCE_PATH to $DEST_PATH.${RESET}"
              fi

              # update package.json path
              CURR_PACKAGE_JSON="${BASE_DIR}/extensions/${NAME}/${VERSION}/plugin/package.json"
              NEW_ICON_PATH="https://raw.githubusercontent.com/${REPOSITORY}/${BRANCH}/icons/${NAME}/${NEW_ICON_NAME}.${EXTENSION}"
              jq --arg key "icon" --arg value "$NEW_ICON_PATH" '.[$key] = $value' "$CURR_PACKAGE_JSON" > "$CURR_PACKAGE_JSON.tmp" && mv "$CURR_PACKAGE_JSON.tmp" "$CURR_PACKAGE_JSON"
              
              echo -e "${BOLD}${GREEN}ICON ::: =>=>=> New ICON ${NEW_ICON_PATH} should have been successfully applied${RESET}"
            fi

            # everything that has to do with ANNOTATIONS or README will need repackaging the TGZ
            if [[ "$APPLY_README" == "true" || "$APPLY_NAME" == "true" || "$APPLY_ANNOTATIONS" == "true" ]]; then
              # handle TGZ file (copy it to TMP folder)
              CURR_TGZ_FOLDER="${BASE_DIR}/assets/${NAME}"
              CURR_TGZ="${CURR_TGZ_FOLDER}/${NAME}-${VERSION}.tgz"

              cp "$CURR_TGZ" "$TMP"
              echo "Copied $CURR_TGZ to $TMP"

              TGZ_FILENAME="${NAME}-${VERSION}.tgz"
              TMP_TGZ="${TMP}/${TGZ_FILENAME}"

              echo "Extracting contents..."
              
              # The 'z' flag is for g-zip, 'x' for extract, 'f' for file, 'v' for verbose output
              tar -xzf "$TMP_TGZ" -C $TMP

              EXTRACTED_FOLDER="${TMP}/${NAME}"

              # Check if extraction created the expected folder
              if [ ! -d "${EXTRACTED_FOLDER}" ]; then
                echo -e "${BOLD}${RED}Error: Extraction did not create the expected folder ${TMP}/${NAME}. Check the contents of $TMP_TGZ.${RESET}"
                exit 1
              fi

              echo "Contents extracted to ${TMP}/$NAME folder"

              # handle README
              if [[ "$APPLY_README" == "true" ]]; then
                # copy README to /charts folder
                cp -fr $NEW_README ${BASE_DIR}/charts/${NAME}/${VERSION}
                echo -e "${GREEN}README ::: README file successfully copied to /charts folder!!!${RESET}"
                
                # copy README to TGZ temp folder assets
                cp -fr $NEW_README ${TMP}/${NAME}
                echo -e "${GREEN}README ::: README file successfully updated on temp tgz folder!!!${RESET}"
              fi

              # handle DISPLAY NAME
              if [[ "$APPLY_NAME" == "true" ]]; then
                # apply annotations to ./charts/... files (it's a pure YAML, not a JSON...)
                CURR_CHART_YAML="${BASE_DIR}/charts/${NAME}/${VERSION}/Chart.yaml"

                if [[ ! -f "$CURR_CHART_YAML" ]]; then
                  echo -e "${RED}${BOLD}PATCH NAME ::: There's no ${CURR_CHART_YAML} on the extension!!!! something is seriously wrong!!! let's terminate this operation!${RESET}"
                  exit 1
                else
                  yq ".annotations[\"catalog.cattle.io/display-name\"] = \"$PATCH_NAME\"" "$CURR_CHART_YAML" -i
                  
                  echo -e "${GREEN}PATCH NAME ::: =>=>=> New patch NAME applied => ${PATCH_NAME} should have been successfully applied to ${CURR_CHART_YAML}${RESET}"
                  echo "-----------"
                fi

                CURR_VALUES_YAML="${BASE_DIR}/charts/${NAME}/${VERSION}/values.yaml"

                if [[ ! -f "$CURR_VALUES_YAML" ]]; then
                  echo -e "${RED}${BOLD}PATCH NAME ::: There's no ${CURR_VALUES_YAML} on the extension!!!! something is seriously wrong!!! let's terminate this operation!${RESET}"
                  exit 1
                else
                  yq ".plugin.metadata[\"catalog.cattle.io/display-name\"] = \"$PATCH_NAME\"" "$CURR_VALUES_YAML" -i
                  
                  echo -e "${GREEN}PATCH NAME ::: =>=>=> New patch NAME applied => ${PATCH_NAME} should have been successfully applied to ${CURR_VALUES_YAML}${RESET}"
                  echo "-----------"
                fi

                # apply annotations to TGZ files
                TMP_CHART_YAML="${TMP}/${NAME}/Chart.yaml"

                if [[ ! -f "$TMP_CHART_YAML" ]]; then
                  echo -e "${RED}${BOLD}PATCH NAME ::: There's no ${TMP_CHART_YAML} on the extension!!!! something is seriously wrong!!! let's terminate this operation!${RESET}"
                  exit 1
                else
                  yq ".annotations[\"catalog.cattle.io/display-name\"] = \"$PATCH_NAME\"" "$TMP_CHART_YAML" -i
                  
                  echo -e "${GREEN}PATCH NAME ::: =>=>=> New patch NAME applied => ${PATCH_NAME} should have been successfully applied to ${TMP_CHART_YAML}${RESET}"
                  echo "-----------"
                fi

                TMP_VALUES_YAML="${TMP}/${NAME}/values.yaml"

                if [[ ! -f "$TMP_VALUES_YAML" ]]; then
                  echo -e "${RED}${BOLD}PATCH NAME ::: There's no ${TMP_VALUES_YAML} on the extension!!!! something is seriously wrong!!! let's terminate this operation!${RESET}"
                  exit 1
                else
                  yq ".plugin.metadata[\"catalog.cattle.io/display-name\"] = \"$PATCH_NAME\"" "$TMP_VALUES_YAML" -i
                  
                  echo -e "${GREEN}PATCH NAME ::: =>=>=> New patch NAME applied => ${PATCH_NAME} should have been successfully applied to ${TMP_VALUES_YAML}${RESET}"
                  echo "-----------"
                fi
              fi

              # handle ANNOTATIONS
              if [[ "$APPLY_ANNOTATIONS" == "true" ]]; then
                echo -e "${GREEN}ANNOTATIONS ::: ANNOTATIONS to be handled here....${RESET}"

                # Store the current IFS value
                CURRENT_IFS="$IFS"
                
                # Set IFS to pipe for splitting the key-value pairs
                IFS='|' read -r -a ANNO_ARRAY <<< "$ANNO_STRING"
                
                for ANNO_PAIR in "${ANNO_ARRAY[@]}"; do
                  # Set IFS to equal sign for splitting the key=value pair
                  IFS='=' read -r ANN_KEY ANN_VALUE <<< "$ANNO_PAIR"
                  
                  # Optional: Clean up inner quotes if needed
                  ANN_KEY="${ANN_KEY//\"/}"
                  ANN_VALUE="${ANN_VALUE//\"/}"

                  # apply annotations to ./charts/... files (it's a pure YAML, not a JSON...)
                  CURR_CHART_YAML="${BASE_DIR}/charts/${NAME}/${VERSION}/Chart.yaml"

                  if [[ ! -f "$CURR_CHART_YAML" ]]; then
                    echo -e "${RED}${BOLD}ANNOTATIONS ::: There's no ${CURR_CHART_YAML} on the extension!!!! something is seriously wrong!!! let's terminate this operation!${RESET}"
                    exit 1
                  else
                    yq ".annotations[\"${ANN_KEY}\"] = \"$ANN_VALUE\"" "$CURR_CHART_YAML" -i
                    
                    echo -e "${GREEN}ANNOTATIONS ::: =>=>=> New annotation ${ANN_KEY} => ${ANN_VALUE} should have been successfully applied to ${CURR_CHART_YAML}${RESET}"
                    echo "-----------"
                  fi

                  CURR_VALUES_YAML="${BASE_DIR}/charts/${NAME}/${VERSION}/values.yaml"

                  if [[ ! -f "$CURR_VALUES_YAML" ]]; then
                    echo -e "${RED}${BOLD}ANNOTATIONS ::: There's no ${CURR_VALUES_YAML} on the extension!!!! something is seriously wrong!!! let's terminate this operation!${RESET}"
                    exit 1
                  else
                    yq ".plugin.metadata[\"${ANN_KEY}\"] = \"$ANN_VALUE\"" "$CURR_VALUES_YAML" -i
                    
                    echo -e "${GREEN}ANNOTATIONS ::: =>=>=> New annotation ${ANN_KEY} => ${ANN_VALUE} should have been successfully applied to ${CURR_VALUES_YAML}${RESET}"
                    echo "-----------"
                  fi

                  # apply annotations to TGZ files
                  TMP_CHART_YAML="${TMP}/${NAME}/Chart.yaml"

                  if [[ ! -f "$TMP_CHART_YAML" ]]; then
                    echo -e "${RED}${BOLD}ANNOTATIONS ::: There's no ${CURR_CHART_YAML} on the extension!!!! something is seriously wrong!!! let's terminate this operation!${RESET}"
                    exit 1
                  else
                    yq ".annotations[\"${ANN_KEY}\"] = \"$ANN_VALUE\"" "$TMP_CHART_YAML" -i
                    
                    echo -e "${GREEN}ANNOTATIONS ::: =>=>=> New annotation ${ANN_KEY} => ${ANN_VALUE} should have been successfully applied to ${TMP_CHART_YAML}${RESET}"
                    echo "-----------"
                  fi

                  TMP_VALUES_YAML="${TMP}/${NAME}/values.yaml"

                  if [[ ! -f "$TMP_VALUES_YAML" ]]; then
                    echo -e "${RED}${BOLD}ANNOTATIONS ::: There's no ${CURR_CHART_YAML} on the extension!!!! something is seriously wrong!!! let's terminate this operation!${RESET}"
                    exit 1
                  else
                    yq ".plugin.metadata[\"${ANN_KEY}\"] = \"$ANN_VALUE\"" "$TMP_VALUES_YAML" -i
                    
                    echo -e "${GREEN}ANNOTATIONS ::: =>=>=> New annotation ${ANN_KEY} => ${ANN_VALUE} should have been successfully applied to ${TMP_VALUES_YAML}${RESET}"
                    echo "-----------"
                  fi
                done
                
                # Restore the IFS to its previous value
                IFS="$CURRENT_IFS"
              fi

              # delete old temp TGZ
              rm -rf "$TMP_TGZ"

              pushd "$TMP" > /dev/null

              #repackage TGZ, apply correct permissions and move it to the correct folder
              # Use 'p' flag for permissions (preserve), 'c' for create, 'z' for g-zip, 'f' for file
              # compress only the /${NAME} dir
              tar -czpf "$TGZ_FILENAME" "$NAME"

              popd > /dev/null

              echo "Created new TGZ: $TMP_TGZ"

              # Get the permissions and ownership from the original file
              if stat -c "" /dev/null > /dev/null 2>&1; then
                # GNU Stat (Linux) - Supports -c
                ORIG_PERM=$(stat -c "%a" "$CURR_TGZ")
                ORIG_OWNER=$(stat -c "%u:%g" "$CURR_TGZ")
              else
                # BSD Stat (macOS) - Requires -f
                ORIG_PERM=$(stat -f "%A" "$CURR_TGZ")
                ORIG_OWNER=$(stat -f "%u:%g" "$CURR_TGZ")
              fi

              echo "Original permissions: ${ORIG_PERM}"
              echo "Original owner: ${ORIG_OWNER}"

              # Move the new archive to the desired target location
              mv -f "$TMP_TGZ" "$CURR_TGZ_FOLDER"
              echo "Moved new archive to $CURR_TGZ_FOLDER"

              # Apply the permissions and ownership to the new archive
              chmod "$ORIG_PERM" "$CURR_TGZ"
              chown "$ORIG_OWNER" "$CURR_TGZ"
              echo "Preserved original permissions and ownership."

              # --- Cleanup ---
              rm -rf "$TMP"
              echo "Cleaned up temporary directory: $TMP"

              # since we've updated annotations, we need to regenerate index.yaml
              HELM_INDEX=${BASE_DIR}/index.yaml

              helm repo index ./assets/ --url assets
              cp ./assets/index.yaml ${HELM_INDEX}
              rm -rf ./assets/index.yaml

              echo "index.yaml regenerated"
            else
              echo -e "${PURPLE}Nothing to do with assets/.tgz file...${RESET}"
            fi
          fi

          echo "---------------------------------------------------------"
          echo "--- Traversal Complete ---"
            
        done < <(jq -r "$JQ_QUERY" "$JSON_PATCH")

        # Restore the original IFS after the loop finishes
        IFS="$OLD_IFS"

        
      else
        echo -e "${PURPLE}The JSON file $JSON_PATCH does not exist. we can skip it...${RESET}"
      fi
    fi
  done
done